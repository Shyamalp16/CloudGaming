<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Video Receiver</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    video {
      width: 640px;
      height: 480px;
      border: 1px solid #ccc;
    }
    #log {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      height: 200px;
      overflow-y: scroll;
      background-color: #f9f9f9;
    }
  </style>
</head>
<body>
  <h1>WebRTC Video Receiver</h1>
  <video id="remoteVideo" autoplay controls></video>
  <div id="log"></div>

  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <script>
    const serverUrl = 'ws://localhost:3000';
    let ws;
    let peerConnection;
    const videoElement = document.getElementById('remoteVideo');
    const logElement = document.getElementById('log');
    let dataChannel;

    // Simple logging function to display logs in the UI
    function log(message) {
        console.log(message);
        const p = document.createElement('p');
        p.textContent = message;
        logElement.appendChild(p);
        logElement.scrollTop = logElement.scrollHeight;
    }

    function connectToSignalingServer() {
        ws = new WebSocket(serverUrl);

        ws.onopen = () => {
            log('Connected to signaling server');
        };

        ws.onmessage = async (event) => {
            try {
                const msg = JSON.parse(event.data);
                log('Received from server: ' + JSON.stringify(msg, null, 2));

                switch (msg.type) {
                    case 'answer':
                        await handleAnswer(msg);
                        break;
                    case 'ice-candidate':
                        await handleRemoteIceCandidate(msg.candidate);
                        break;
                    case 'offer':
                        log('Unexpected Offer Received, This Client Will Always Be The Offerer.');
                        break;
                    default:
                        log('Unknown Message Type: ' + msg.type);
                }
            } catch (err) {
                log('Error processing WebSocket message: ' + err.message);
            }
        };

        ws.onerror = (err) => {
            log('WebSocket Error: ' + err.message);
        };

        ws.onclose = () => {
            log('WebSocket connection closed');
        };
    }

    function createPeerConnection() {
        const config = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
        };
        peerConnection = new RTCPeerConnection(config);

        peerConnection.ontrack = (event) => {
            log('Received remote track: ' + event.track.kind + ' ' + event.track.id);
            if (event.track.kind === 'video') {
                const stream = event.streams[0];
                videoElement.srcObject = stream;
                log('Stream active: ' + stream.active + ', Tracks: ' + stream.getTracks().length);
                videoElement.onloadedmetadata = () => log('Video metadata loaded');
                videoElement.onplaying = () => log('Video playing');
                videoElement.onerror = (e) => log('Video error: ' + e);
            }
        };

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                log('Local ICE Candidate: ' + JSON.stringify(event.candidate, null, 2));
                ws.send(JSON.stringify({
                    type: 'ice-candidate',
                    candidate: event.candidate
                }));
            } else {
                log('ICE candidate gathering complete');
            }
        };

        peerConnection.oniceconnectionstatechange = () => {
            log('ICE connection state changed to: ' + peerConnection.iceConnectionState);
        };

        peerConnection.onicegatheringstatechange = () => {
            log('ICE gathering state changed to: ' + peerConnection.iceGatheringState);
        };

        peerConnection.onconnectionstatechange = () => {
            log('PeerConnection state changed to: ' + peerConnection.connectionState);
        };

        peerConnection.onsignalingstatechange = () => {
            log('Signaling state changed to: ' + peerConnection.signalingState);
        };

        dataChannel = peerConnection.createDataChannel("keyPressChannel", {ordered: true})
        log(`Client attempting to create data channel "${dataChannel.label}", initial state: ${dataChannel.readyState}`);
        log('Data Channel Received: ' + dataChannel.label + ', readyState: ' + dataChannel.readyState);

        dataChannel.onopen = () => {
            log('Data Channel Opened: ' + dataChannel.label + ', readyState: ' + dataChannel.readyState);                // receiveChannel.send('Hello From The Receiver!');
            // sendKeyPress({ key: 'c', code: 'KeyC', timestamp: Date.now() });
        };
        dataChannel.onmessage = (event) => {
            log('Received Message on Data Channel: ' + event.data);
        };
        dataChannel.onclose = () => {
            log('Data Channel Closed: ' + dataChannel.label);
        };
        dataChannel.onerror = (err) => {
            const errorMessage = err.message || (err.name ? `${err.name}: ${err.code}` : 'Unknown DataChannel Error');
            log(`Data Channel "${dataChannel.label}" error: ${errorMessage}`);
        };
    }

    async function handleAnswer(answerMsg) {
        log('Received SDP in answer: ' + JSON.stringify(answerMsg, null, 2));
        if (!answerMsg.sdp || typeof answerMsg.sdp !== 'string' || !answerMsg.sdp.startsWith('v=')) {
            log('Invalid or missing SDP in answer: ' + JSON.stringify(answerMsg));
            return;
        }
        try {
            const remoteDesc = new RTCSessionDescription({ type: 'answer', sdp: answerMsg.sdp });
            await peerConnection.setRemoteDescription(remoteDesc);
            log('Remote description set with answer');
        } catch (err) {
            log('Error setting remote description: ' + err.message);
        }
    }

    async function handleRemoteIceCandidate(candidate) {
        try {
            await peerConnection.addIceCandidate(candidate);
            log('Added remote ICE candidate: ' + JSON.stringify(candidate, null, 2));
        } catch (err) {
            log('Error adding received ICE candidate: ' + err.message);
        }
    }

    function sendKeyPress(keyData){
        if(dataChannel && dataChannel.readyState === 'open'){
            const message = JSON.stringify(keyData)
            dataChannel.send(message)
            log('Sent Keypress: ' + message)
        }else{
            log('Data channel not open, cannot send keypress: ' + JSON.stringify(keyData));
            if(dataChannel){
                // setTimeout(() => sendKeypress(keyData), 1000);
            }else{
                log('Data channel is null, check WebRTC setup');
            }
        }
    }

    async function startConnection() {
        if (!peerConnection) createPeerConnection();

        peerConnection.addTransceiver('video', {
            direction: 'recvonly',
        });

        // document.addEventListener('keydown', (event) => {
        //     if(dataChannel.readyState == 'open'){
        //         const keyData = {
        //             key: event.key,
        //             code: event.code,
        //             timestamp: Date.now()
        //         };
        //         dataChannel.send(JSON.stringify(keyData));
        //         log('Sent keypress: ' + JSON.stringify(keyData));
        //     }
        // })

        document.addEventListener('keydown', (event) => {
            const keyData = {
                key: event.key,
                code: event.code,
                type: 'keydown',
                timestamp: Date.now()
            };
            sendKeyPress(keyData);
        });

        document.addEventListener('keyup', (event) => {
            const keyData = {
                key: event.key,
                code: event.code,
                type: 'keyup',
                timestamp: Date.now()
            };
            sendKeyPress(keyData);
        });

        try {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            ws.send(JSON.stringify({
                type: 'offer',
                sdp: offer.sdp
            }));
            log('Offer Sent: ' + offer.sdp);
        } catch (err) {
            log('Error creating or setting offer: ' + err.message);
        }
    }

    connectToSignalingServer();

    setTimeout(() => {
        if(ws && ws.readyState === WebSocket.OPEN){
            startConnection();
        }else{
            log("WebSocket not connected after timeout. Waiting for connection to start WebRTC.");
            const wsOpenCheck = setInterval(() => {
                if(ws && ws.readyState === WebSocket.OPEN){
                    clearInterval(wsOpenCheck);
                    startConnection();
                }
            }, 500)
        }
    }, 2000);
</script>
</body>
</html>